# gRPC & SignalR - Complete Line-by-Line Walkthrough

---

# SECTION 1: GRPC COMPLETE WALKTHROUGH - GetAccount Operation

## Scenario
Client calls: **"Get account details for account number 1000000001"**

---

## STEP 1: Client Sends gRPC Request

### What the client sends:

```protobuf
// Proto definition (account.proto)
service AccountService {
    rpc GetAccount (GetAccountRequest) returns (AccountResponse);
}

message GetAccountRequest {
    string account_number = 1;
}
```

### Client code (e.g., grpcurl or .NET client):

```bash
# Using grpcurl tool
grpcurl -plaintext -d '{"account_number": "1000000001"}' \
  localhost:7288 corebanking.AccountService/GetAccount
```

OR

```csharp
// .NET Client
var channel = GrpcChannel.ForAddress("https://localhost:7288");
var client = new AccountService.AccountServiceClient(channel);

var request = new GetAccountRequest 
{ 
    AccountNumber = "1000000001" 
};

var response = await client.GetAccountAsync(request);
```

### What happens in binary:

```
Step 1a: Request object created
┌────────────────────────────────┐
│ GetAccountRequest              │
│ {                              │
│   account_number: "1000000001" │
│ }                              │
└────────────────────────────────┘
        ↓
Step 1b: Serialized to binary (protobuf)
┌────────────────────────────────┐
│ Binary (hex):                  │
│ 0A 0A 31 30 30 30 30 30 30 30  │
│ 30 30 31                        │
│                                │
│ (TINY! Only ~15 bytes!)        │
└────────────────────────────────┘
        ↓
Step 1c: Sent over HTTP/2 connection
┌────────────────────────────────┐
│ HTTP/2 Frame:                  │
│ :method = POST                 │
│ :path = /corebanking.          │
│         AccountService/GetAccount│
│ :scheme = https                │
│ host = localhost:7288          │
│ [binary payload]               │
└────────────────────────────────┘
```

---

## STEP 2: Server Receives on Port 7288

### Server Configuration (Program.cs):

```csharp
// Line 70-74: Add gRPC
builder.Services.AddGrpc(options =>
{
    // Line 73: Enable detailed errors for debugging
    options.EnableDetailedErrors = true;
});

// Line 75: Add reflection (allows grpcurl to discover services)
builder.Services.AddGrpcReflection();

// Line 112-123: Configure Kestrel to listen on TWO ports
builder.WebHost.ConfigureKestrel(options =>
{
    // Line 115: HTTP/1.1 for REST API (port 5037)
    options.ListenLocalhost(5037, o => o.Protocols = HttpProtocols.Http1);

    // Line 118-122: HTTP/2 for gRPC (port 7288)
    options.ListenLocalhost(7288, o =>
    {
        o.UseHttps();  // Require HTTPS
        o.Protocols = HttpProtocols.Http2;  // ONLY HTTP/2
    });
});

// Line 197-198: Map gRPC services
app.MapGrpcService<AccountGrpcService>();
app.MapGrpcService<EnhancedAccountGrpcService>();
```

**What happens:**

```
Client connects to localhost:7288
        ↓
Kestrel HTTP/2 handler detects connection
        ↓
Kestrel says: "This is HTTP/2, route to gRPC handler"
        ↓
Reads HTTP/2 frame:
    :method = POST
    :path = /corebanking.AccountService/GetAccount
        ↓
Kestrel routes to: AccountGrpcService class
        ↓
Calls: GetAccount() method
```

---

## STEP 3: Route to AccountGrpcService

### File: `CoreBankingTest.API/gRPC/Services/AccountGrpcService.cs`

```csharp
// Line 14: Class inherits from auto-generated base class
public class AccountGrpcService : AccountService.AccountServiceBase
{
    //          ↑ Auto-generated by protobuf compiler from account.proto
    
    // Line 16-18: Dependencies injected via constructor
    private readonly IMediator _mediator;
    private readonly IMapper _mapper;
    private readonly ILogger<AccountGrpcService> _logger;

    // Line 20-25: Constructor
    public AccountGrpcService(IMediator mediator, IMapper mapper, ILogger<AccountGrpcService> logger)
    {
        _mediator = mediator;
        _mapper = mapper;
        _logger = logger;
    }

    // Line 27-56: THE METHOD THAT EXECUTES
    public override async Task<AccountResponse> GetAccount(
        GetAccountRequest request,           // ← Client's data (account_number)
        ServerCallContext context)           // ← RPC metadata (connection info, timeout, etc.)
    {
        // ========== LINE BY LINE EXPLANATION ==========
        
        // LINE 30: Log the incoming request
        _logger.LogInformation(
            "gRPC GetAccount called for {AccountNumber}", 
            request.AccountNumber
        );
        // Output: "gRPC GetAccount called for 1000000001"
        
        // LINE 33-34: VALIDATION - Check if account number is provided
        if (string.IsNullOrWhiteSpace(request.AccountNumber))
            throw new RpcException(
                new Status(
                    StatusCode.InvalidArgument,  // gRPC error code
                    "Account number is required"  // Error message
                )
            );
        // If account_number is empty, reject immediately with gRPC error
        
        // LINE 36: Try-catch to handle errors gracefully
        try
        {
            // LINE 38: Create domain value object
            var accountNumber = AccountNumber.Create(request.AccountNumber);
            //              ↑ Validates: must be 10 digits
            //              ↑ If invalid, throws exception caught below
            
            // LINE 39: Create CQRS Query object
            var query = new GetAccountDetailsQuery 
            { 
                AccountNumber = accountNumber 
            };
            //  ↑ This query will be processed by MediatR pipeline
            
            // LINE 40: Send query through MediatR pipeline
            var result = await _mediator.Send(query);
            //         ↑ This executes:
            //           1. Validation behavior
            //           2. Logging behavior
            //           3. Domain events behavior
            //           4. Actual query handler (GetAccountDetailsQueryHandler)
            //         ↑ Waits for handler to complete (async/await)
            
            // LINE 42-49: Check if query was successful
            if (result.IsSuccess)
            {
                // LINE 44: Map domain model to gRPC response
                return _mapper.Map<AccountResponse>(result.Data);
                //     ↑ AutoMapper converts:
                //       Domain Account object → gRPC AccountResponse message
                //
                // Example mapping:
                // From: Account { accountNumber = "1000000001", balance = 5000 }
                // To:   AccountResponse { account_number = "1000000001", balance = 5000 }
            }
            else
            {
                // LINE 48: Query failed (account not found)
                throw new RpcException(
                    new Status(
                        StatusCode.NotFound,
                        string.Join("; ", result.Errors)
                        // Join multiple errors with semicolon
                    )
                );
            }
        }
        catch (Exception ex) when (ex is not RpcException)
        {
            // LINE 53: Log unexpected errors
            _logger.LogError(
                ex,
                "Error retrieving account {AccountNumber}",
                request.AccountNumber
            );
            
            // LINE 54: Return generic error to client
            throw new RpcException(
                new Status(
                    StatusCode.Internal,
                    "Internal server error"
                )
            );
        }
    }
}
```

---

## STEP 4: MediatR Pipeline Execution

### What happens inside `_mediator.Send(query)`:

```
PIPELINE FLOW:
═════════════════════════════════════════════════════════════════

Input: GetAccountDetailsQuery { AccountNumber = "1000000001" }
  │
  ├─────────────────────────────────────────────────────────────┐
  │                                                             │
  ▼ ENTER PIPELINE                                             │
                                                               │
┌─────────────────────────────────────────────────────────────┐│
│ BEHAVIOR 1: ValidationBehavior<GetAccountDetailsQuery>     ││
├─────────────────────────────────────────────────────────────┤│
│                                                             ││
│ Purpose: Validate query before processing                  ││
│                                                             ││
│ Line 1: Check if AccountNumber is null                     ││
│         ✓ VALID (it's "1000000001")                         ││
│                                                             ││
│ Line 2: Check if AccountNumber matches pattern             ││
│         ✓ VALID (10 digits)                                 ││
│                                                             ││
│ Result: PASS, proceed to next behavior                     ││
└─────────────────────────────────────────────────────────────┘│
  │                                                             │
  ▼                                                             │
┌─────────────────────────────────────────────────────────────┐│
│ BEHAVIOR 2: LoggingBehavior<GetAccountDetailsQuery>        ││
├─────────────────────────────────────────────────────────────┤│
│                                                             ││
│ Line 1: Log request received                               ││
│         Output: "Handling GetAccountDetailsQuery"           ││
│                                                             ││
│ Line 2: Record timestamp                                   ││
│         StartTime = 16:22:08.000                            ││
│                                                             ││
│ Result: Continue, measure execution time                   ││
└─────────────────────────────────────────────────────────────┘│
  │                                                             │
  ▼                                                             │
┌─────────────────────────────────────────────────────────────┐│
│ BEHAVIOR 3: DomainEventsBehavior<GetAccountDetailsQuery>  ││
├─────────────────────────────────────────────────────────────┤│
│                                                             ││
│ Line 1: Prepare domain event handlers                      ││
│         Register: MoneyTransferredEventHandler             ││
│         Register: AccountCreatedEventHandler               ││
│                                                             ││
│ Result: Ready to fire events after handler completes       ││
└─────────────────────────────────────────────────────────────┘│
  │                                                             │
  ▼                                                             │
┌─────────────────────────────────────────────────────────────┐│
│ ACTUAL HANDLER: GetAccountDetailsQueryHandler              ││
├─────────────────────────────────────────────────────────────┤│
│                                                             ││
│ public class GetAccountDetailsQueryHandler                 ││
│     : IQueryHandler<                                        ││
│         GetAccountDetailsQuery,                             ││
│         QueryResult<AccountDetails>                         ││
│     >                                                       ││
│ {                                                           ││
│     public async Task<QueryResult<AccountDetails>>         ││
│         Handle(GetAccountDetailsQuery query, ...)          ││
│     {                                                       ││
│         Line 1: Get account number from query              ││
│                 accountNumber = "1000000001"               ││
│                                                             ││
│         Line 2: Query database via repository              ││
│                 SELECT * FROM Accounts                     ││
│                 WHERE AccountNumber = '1000000001'         ││
│                                                             ││
│         Line 3: Database returns account                   ││
│                 Account {                                  ││
│                   AccountNumber: "1000000001"              ││
│                   Balance: 5000.00                         ││
│                   AccountType: "Savings"                   ││
│                   IsActive: true                           ││
│                 }                                          ││
│                                                             ││
│         Line 4: Check if found                             ││
│                 if (account == null)                       ││
│                     return QueryResult.Failure(...)        ││
│                 else                                       ││
│                     return QueryResult.Success(account)    ││
│                                                             ││
│         RETURN:                                             ││
│         QueryResult<AccountDetails> {                      ││
│             IsSuccess: true,                               ││
│             Data: AccountDetails {                         ││
│                 AccountNumber: "1000000001",               ││
│                 Balance: 5000.00,                          ││
│                 AccountType: "Savings",                    ││
│                 IsActive: true                             ││
│             }                                              ││
│         }                                                  ││
│     }                                                       ││
│ }                                                           ││
│                                                             ││
└─────────────────────────────────────────────────────────────┘│
  │                                                             │
  ▼ RETURN FROM HANDLER                                        │
                                                               │
Result goes back through behaviors (in reverse order):         │
  │                                                             │
  ├─────────────────────────────────────────────────────────────┐
  │                                                             │
  ▼ BEHAVIOR 3 (RETURN): DomainEventsBehavior                ││
├─────────────────────────────────────────────────────────────┐│
│                                                             ││
│ Line 1: Check if domain events were raised                 ││
│         events = account.DomainEvents  // Empty for read   ││
│                                                             ││
│ Line 2: No events (this is a query, not a command)         ││
│                                                             ││
│ Result: Return result unchanged                            ││
│                                                             ││
└─────────────────────────────────────────────────────────────┘│
  │                                                             │
  ▼ BEHAVIOR 2 (RETURN): LoggingBehavior                      ││
├─────────────────────────────────────────────────────────────┐│
│                                                             ││
│ Line 1: Record end time                                    ││
│         EndTime = 16:22:08.045 (45 milliseconds)           ││
│                                                             ││
│ Line 2: Log completion                                     ││
│         Output: "Query completed in 45ms"                  ││
│                                                             ││
│ Result: Return result unchanged                            ││
│                                                             ││
└─────────────────────────────────────────────────────────────┘│
  │                                                             │
  ▼ BEHAVIOR 1 (RETURN): ValidationBehavior                   ││
├─────────────────────────────────────────────────────────────┐│
│                                                             ││
│ Line 1: Result already validated on entry                  ││
│                                                             ││
│ Result: Return result unchanged                            ││
│                                                             ││
└─────────────────────────────────────────────────────────────┘│
  │                                                             │
  ▼ EXIT PIPELINE                                             │
                                                               │
Output: QueryResult<AccountDetails> {                         │
    IsSuccess: true,                                          │
    Data: AccountDetails {                                    │
        AccountNumber: "1000000001",                          │
        Balance: 5000.00,                                     │
        AccountType: "Savings",                               │
        IsActive: true                                        │
    }                                                         │
}                                                             │
```

---

## STEP 5: AutoMapper Conversion

### File: Auto Mapping Profile

```csharp
// In AutoMapper configuration
public class AccountGrpcProfile : Profile
{
    public AccountGrpcProfile()
    {
        // Line 1: Map from domain model
        CreateMap<Account, AccountResponse>()
            // Line 2: domain.AccountNumber → response.AccountNumber
            .ForMember(
                dest => dest.AccountNumber,
                opt => opt.MapFrom(src => src.AccountNumber.ToString())
                //                ↑ Convert value object to string
            )
            // Line 3: domain.Balance → response.Balance
            .ForMember(
                dest => dest.Balance,
                opt => opt.MapFrom(src => (double)src.Balance.Amount)
                //     ↑ Convert Money value object to double
            )
            // Line 4: domain.Currency → response.Currency
            .ForMember(
                dest => dest.Currency,
                opt => opt.MapFrom(src => src.Balance.Currency)
            )
            // Line 5: domain.IsActive → response.IsActive
            .ForMember(
                dest => dest.IsActive,
                opt => opt.MapFrom(src => src.IsActive)
            )
            // Line 6: domain.DateOpened → response.DateOpened (timestamp)
            .ForMember(
                dest => dest.DateOpened,
                opt => opt.MapFrom(src => 
                    Timestamp.FromDateTime(src.DateOpened.ToUniversalTime())
                    //  ↑ Convert C# DateTime to protobuf Timestamp
                )
            );
    }
}
```

**What the mapper produces:**

```csharp
// Input (domain Account object)
Account {
    AccountNumber: AccountNumber("1000000001"),  // Value object
    Balance: Money(5000.00, "NGN"),              // Value object
    AccountType: "Savings",
    IsActive: true,
    DateOpened: new DateTime(2023, 01, 15)
}

                    ↓ (AutoMapper)

// Output (gRPC AccountResponse message)
AccountResponse {
    account_number = "1000000001",       // Converted to string
    balance = 5000.0,                    // Converted to double
    currency = "NGN",
    account_type = "Savings",
    is_active = true,
    date_opened = Timestamp {            // Converted to protobuf Timestamp
        seconds: 1673740800
        nanos: 0
    }
}
```

---

## STEP 6: Serialize Response to Binary

```csharp
// gRPC framework automatically serializes AccountResponse

AccountResponse {
    account_number = "1000000001",
    balance = 5000.0,
    currency = "NGN",
    account_type = "Savings",
    is_active = true,
    date_opened = Timestamp { seconds: 1673740800 }
}

        ↓ (Protobuf serializer)

BINARY FORMAT (hex):
─────────────────────────────────────────
Field 1 (account_number): 0A 0A 31 30 30 30 30 30 30 30 30 31
                              ↑  ↑                              
                              tag wire format
                              0A = field 1, wire format 2 (length-delimited)
                              0A = length 10 bytes

Field 2 (account_type): 12 07 53 61 76 69 6E 67 73
                        ↑  ↑
                        tag length
                        12 = field 2, wire format 2

Field 3 (balance): 19 00 00 00 00 00 88 B3 40
                   ↑
                   19 = field 3, wire format 1 (fixed64)

... (continues for other fields)

TOTAL SIZE: ~80 bytes (MUCH smaller than JSON!)
```

---

## STEP 7: Send Response Over HTTP/2

```
HTTP/2 Response Frame:
─────────────────────────────────────────

Headers:
:status = 200                  // Success!
content-type = application/grpc+proto
grpc-status = 0                // No error

Data Frame:
[80 bytes of binary protobuf]

Trailers:
grpc-status = 0
grpc-message = ""
```

---

## STEP 8: Client Receives & Deserializes

```csharp
// Client receives HTTP/2 response

// gRPC framework automatically deserializes binary data

BINARY DATA:
0A 0A 31 30 30 30 30 30 30 30 30 31 12 07 53 61 76 69 6E 67 73 19 00 00 00...

        ↓ (Protobuf deserializer)

C# Object:
AccountResponse {
    account_number = "1000000001",
    balance = 5000.0,
    currency = "NGN",
    account_type = "Savings",
    is_active = true,
    date_opened = Timestamp { seconds: 1673740800 }
}

        ↓ (Client code)

Console.WriteLine($"Balance: {response.Balance}");
// Output: Balance: 5000

Console.WriteLine($"Account Type: {response.AccountType}");
// Output: Account Type: Savings
```

---

## COMPLETE EXECUTION TIMELINE

```
TIME         EVENT
─────────────────────────────────────────────────────────────

T+0ms        Client calls grpcurl
             grpcurl sends binary request to localhost:7288

T+1ms        Kestrel HTTP/2 handler receives data
             Routes to AccountGrpcService.GetAccount()

T+2ms        AccountGrpcService.GetAccount() starts
             - Validates input: ✓
             - Creates AccountNumber value object
             - Creates GetAccountDetailsQuery
             - Calls mediator.Send(query)

T+3ms        MediatR pipeline starts
             - ValidationBehavior: ✓ PASS
             - LoggingBehavior: ✓ START timing
             - DomainEventsBehavior: ✓ PREPARE
             - GetAccountDetailsQueryHandler: execute

T+4ms        Database query
             SELECT * FROM Accounts WHERE AccountNumber = '1000000001'

T+45ms       Database returns result
             Account object populated with data

T+46ms       Handler returns QueryResult<AccountDetails>
             MediatR pipeline returns

T+47ms       AutoMapper converts domain model to gRPC response
             Account → AccountResponse

T+48ms       gRPC framework serializes to binary protobuf
             80 bytes of binary data

T+49ms       HTTP/2 sends response
             Headers + Data frame

T+50ms       Client receives response
             Deserializes binary to AccountResponse object

T+51ms       Client code executes
             var balance = response.Balance;
             // balance = 5000.0

TOTAL TIME: 51 milliseconds
```

---

---

# SECTION 2: SIGNALR COMPLETE WALKTHROUGH - Money Transfer Notification

## Scenario
User A transfers $100 from account 123456789 to User B's account 987654321.
Both users are viewing their accounts in real-time.

---

## STEP 1: User A Initiates Transfer

### REST API Endpoint Called

```csharp
// File: CoreBankingTest.API/Controllers/TransfersController.cs (hypothetical)

[HttpPost("accounts/{sourceId}/transfer")]
public async Task<IActionResult> TransferMoney(TransferMoneyRequest request)
{
    // LINE 1: Create command for transfer
    var command = new TransferMoneyCommand
    {
        SourceAccountNumber = AccountNumber.Create(request.SourceAccountNumber),
        //                    "123456789"
        DestinationAccountNumber = AccountNumber.Create(request.DestinationAccountNumber),
        //                          "987654321"
        Amount = new Money(
            (decimal)request.Amount,      // 100.00
            request.Currency              // "NGN"
        ),
        Reference = request.Reference,
        Description = request.Description
    };

    // LINE 2: Send command through MediatR
    var result = await _mediator.Send(command);
    //         ↑ Goes through MediatR pipeline
    //         ↑ Validation → Logging → Domain Events → Handler
    //         ↑ Handler: TransferMoneyCommandHandler

    // LINE 3: Check if successful
    if (result.IsSuccess)
    {
        return Ok(result);
    }
    else
    {
        return BadRequest(result);
    }
}
```

---

## STEP 2: TransferMoneyCommandHandler Executes

```csharp
// File: CoreBankingTest.APP/Accounts/Commands/TransferMoney/TransferMoneyCommandHandler.cs

public class TransferMoneyCommandHandler 
    : ICommandHandler<TransferMoneyCommand, CommandResult<Guid>>
{
    private readonly IUnitOfWork _unitOfWork;
    // ↑ Handles database transactions atomically

    public async Task<CommandResult<Guid>> Handle(
        TransferMoneyCommand command,
        CancellationToken cancellationToken)
    {
        // ========== LINE BY LINE EXECUTION ==========

        // LINE 1: Get source account from database
        var sourceAccount = await _unitOfWork.Accounts
            .GetByAccountNumberAsync(command.SourceAccountNumber);
        // Returns: Account object with balance 500

        // LINE 2: Get destination account
        var destinationAccount = await _unitOfWork.Accounts
            .GetByAccountNumberAsync(command.DestinationAccountNumber);
        // Returns: Account object with balance 1000

        // LINE 3: Perform transfer (domain logic)
        sourceAccount.Transfer(
            destinationAccount,
            command.Amount,
            command.Reference,
            command.Description
        );
        //       ↑ This calls Account.Transfer() method in domain layer
        //       ↑ Inside: sourceAccount.Balance decreases
        //              : destinationAccount.Balance increases
        //              : MoneyTransferredEvent created and added to sourceAccount.DomainEvents

        // LINE 4: Save both accounts to database
        _unitOfWork.Accounts.Update(sourceAccount);
        _unitOfWork.Accounts.Update(destinationAccount);

        // LINE 5: Commit transaction (atomic save)
        await _unitOfWork.CommitAsync();
        //     ↑ Both accounts saved TOGETHER
        //     ↑ Event added to OutboxMessages table
        //     ↑ MoneyTransferredEvent serialized to JSON in OutboxMessages

        // LINE 6: Return transaction ID
        return CommandResult<Guid>.Success(sourceAccount.LastTransactionId);
    }
}
```

---

## STEP 3: Domain Event Created

```csharp
// Inside Account.Transfer() method (Domain layer)

public class Account : AggregateRoot
{
    public void Transfer(
        Account destination,
        Money amount,
        string reference,
        string description)
    {
        // LINE 1: Validate transfer is possible
        if (this.Balance.Amount < amount.Amount)
            throw new InsufficientFundsException();

        // LINE 2: Debit source account
        this.Balance -= amount;
        //    ↑ Balance: 500 → 400

        // LINE 3: Credit destination account
        destination.Balance += amount;
        //                ↑ Balance: 1000 → 1100

        // LINE 4: CREATE DOMAIN EVENT
        var transferEvent = new MoneyTransferredEvent
        {
            TransactionId = Guid.NewGuid(),
            SourceAccountNumber = this.AccountNumber,      // 123456789
            DestinationAccountNumber = destination.AccountNumber,  // 987654321
            Amount = amount,                                // Money(100, "NGN")
            TransferDate = DateTime.UtcNow,
            Reference = reference,
            Description = description
        };

        // LINE 5: Add event to domain events list
        this.AddDomainEvent(transferEvent);
        //    ↑ Stored in: this._domainEvents (in-memory list)
        //    ↑ NOT persisted to database yet!
    }
}
```

**At this point:**
- Database: source (500), destination (1000)
- Memory: MoneyTransferredEvent object created but NOT persisted

---

## STEP 4: UnitOfWork Saves & Outbox Pattern

```csharp
// File: CoreBankingTest.DAL/UnitOfWork.cs

public class UnitOfWork : IUnitOfWork
{
    private readonly BankingDbContext _dbContext;

    public async Task<bool> CommitAsync()
    {
        // ========== LINE BY LINE EXECUTION ==========

        // LINE 1: Get all domain events from all changed entities
        var domainEvents = new List<IDomainEvent>();

        // Get accounts that were modified
        var changedAccounts = _dbContext.ChangeTracker
            .Entries<Account>()
            .Where(e => e.State == EntityState.Modified)
            .Select(e => e.Entity)
            .ToList();

        // LINE 2: Collect all domain events
        foreach (var account in changedAccounts)
        {
            var events = account.GetDomainEvents();
            //            ↑ Gets: [MoneyTransferredEvent]
            domainEvents.AddRange(events);
        }

        // LINE 3: Create outbox messages for events
        foreach (var @event in domainEvents)
        {
            // LINE 3a: Serialize event to JSON
            var jsonContent = JsonSerializer.Serialize(@event);
            //  Result: 
            //  {
            //    "transactionId": "guid-123",
            //    "sourceAccountNumber": "123456789",
            //    "destinationAccountNumber": "987654321",
            //    "amount": 100,
            //    "transferDate": "2025-11-08T16:22:08Z"
            //  }

            // LINE 3b: Create outbox message
            var outboxMessage = new OutBoxMessage
            {
                Id = Guid.NewGuid(),
                Type = @event.GetType().Name,  // "MoneyTransferredEvent"
                Content = jsonContent,          // JSON string
                OccurredOn = @event.OccurredOn, // 2025-11-08T16:22:08Z
                ProcessedOn = null,             // ← NOT processed yet
                Error = null,
                RetryCount = 0
            };

            // LINE 3c: Add to database context
            _dbContext.OutBoxMessages.Add(outboxMessage);
        }

        // LINE 4: Save ALL changes to database atomically
        await _dbContext.SaveChangesAsync();
        //     ↑ ONE database transaction:
        //       - UPDATE Accounts SET Balance = 400 WHERE AccountNumber = '123456789'
        //       - UPDATE Accounts SET Balance = 1100 WHERE AccountNumber = '987654321'
        //       - INSERT INTO OutBoxMessages VALUES (...)

        // LINE 5: Clear domain events from memory (they're now in database)
        foreach (var account in changedAccounts)
        {
            account.ClearDomainEvents();
        }

        return true;
    }
}
```

**At this point:**
```
Database State:
┌────────────────────────────────────────┐
│ Accounts table                         │
├────────────────────────────────────────┤
│ AccountNumber | Balance                │
│ 123456789     | 400.00                 │  ✓ Updated
│ 987654321     | 1100.00                │  ✓ Updated
└────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────┐
│ OutBoxMessages table                                       │
├────────────────────────────────────────────────────────────┤
│ Id | Type | Content | OccurredOn | ProcessedOn | RetryCount
│ 1  | MoneyTransferredEvent | {...json...} | T+0 | NULL | 0
└────────────────────────────────────────────────────────────┘
                                           ↑
                                    Still waiting!
```

---

## STEP 5: Immediate Event Handler Execution

### After CommitAsync(), Domain Events are published

```csharp
// File: CoreBankingTest.APP/Common/Behaviors/DomainEventsBehavior.cs

public class DomainEventsBehavior<TRequest, TResponse>
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : notnull
{
    private readonly IMediator _mediator;

    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        // LINE 1: Execute the handler (TransferMoneyCommandHandler)
        var response = await next();
        //         ↑ This is where money is transferred & saved

        // LINE 2: Get the request as an aggregate root (if applicable)
        if (request is not HasDomainEvents hasDomainEvents)
            return response;

        // LINE 3: Get all domain events
        var domainEvents = hasDomainEvents.GetDomainEvents();
        //                  ↑ Gets: [MoneyTransferredEvent]

        // LINE 4: Publish each event to all registered handlers
        foreach (var domainEvent in domainEvents)
        {
            // LINE 4a: Publish MoneyTransferredEvent
            await _mediator.Publish(domainEvent, cancellationToken);
            //     ↑ This triggers ALL handlers listening for MoneyTransferredEvent:
            //       - RealTimeNotificationEventHandler    ← SIGNALR HANDLER!
            //       - MoneyTransferedEventHandler         (logging)
            //       - OutboxMessageProcessor              (background)
        }

        return response;
    }
}
```

---

## STEP 6: RealTimeNotificationEventHandler Executes

### File: `CoreBankingTest.API/Hubs/EventHandlers/RealTimeNotificationEventHandler.cs`

```csharp
public class RealTimeNotificationEventHandler 
    : INotificationHandler<MoneyTransferredEvent>
{
    // LINE 1: Dependency: IHubContext to send SignalR messages
    private readonly IHubContext<EnhancedNotificationHub, IBankingClient> _hubContext;
    //                  ↑ Allows sending to SignalR clients without connection info

    public RealTimeNotificationEventHandler(
        ILogger<RealTimeNotificationEventHandler> logger,
        IHubContext<EnhancedNotificationHub, IBankingClient> hubContext)
    {
        _logger = logger;
        _hubContext = hubContext;  // ← Store for use
    }

    // LINE 2: MAIN METHOD - This executes when MoneyTransferredEvent is published
    public async Task Handle(
        MoneyTransferredEvent notification,  // ← The event data
        CancellationToken cancellationToken)
    {
        // ========== LINE BY LINE EXECUTION ==========

        // LINE 3: Log that we're processing event
        _logger.LogInformation(
            "Processing real-time notification for transfer {TransactionId}",
            notification.TransactionId
        );
        // Output: "Processing real-time notification for transfer guid-123"

        // LINE 4: Try-catch to handle errors
        try
        {
            // ═══════════════════════════════════════════════════════════
            // PART A: Send notification to SOURCE account (123456789)
            // ═══════════════════════════════════════════════════════════

            // LINE 5: Create notification for SOURCE account
            var sourceNotification = new TransactionNotification
            {
                TransactionId = notification.TransactionId.ToString(),
                //              guid-123
                AccountNumber = notification.SourceAccountNumber.ToString(),
                //              123456789
                Amount = -notification.Amount.Amount,
                //        -100  (negative = money went out)
                Type = "Debit",
                //      Show it as a debit
                Description = $"Transfer to {notification.DestinationAccountNumber}",
                //            "Transfer to 987654321"
                Timestamp = notification.TransferDate,
                RunningBalance = 0
                //              Would calculate from real balance
            };

            // LINE 6: Send to ALL clients subscribed to account 123456789
            await _hubContext.Clients
                .Group($"account-123456789")
                //     ↑ Group name format: "account-{AccountNumber}"
                .ReceiveTransactionNotification(sourceNotification);
                //↑ This calls ReceiveTransactionNotification() on all connected clients
                //  in the "account-123456789" group

            // ═══════════════════════════════════════════════════════════
            // PART B: Send notification to DESTINATION account (987654321)
            // ═══════════════════════════════════════════════════════════

            // LINE 7: Create notification for DESTINATION account
            var destNotification = new TransactionNotification
            {
                TransactionId = notification.TransactionId.ToString(),
                //              guid-123
                AccountNumber = notification.DestinationAccountNumber.ToString(),
                //              987654321
                Amount = notification.Amount.Amount,
                //        100  (positive = money came in)
                Type = "Credit",
                //      Show it as a credit
                Description = $"Transfer from {notification.SourceAccountNumber}",
                //            "Transfer from 123456789"
                Timestamp = notification.TransferDate,
                RunningBalance = 0
            };

            // LINE 8: Send to ALL clients subscribed to account 987654321
            await _hubContext.Clients
                .Group($"account-987654321")
                //     ↑ Group name
                .ReceiveTransactionNotification(destNotification);
                //↑ All connected clients in this group receive the notification

            // LINE 9: Log success
            _logger.LogInformation(
                "Sent real-time notifications for transfer {TransactionId}",
                notification.TransactionId
            );
            // Output: "Sent real-time notifications for transfer guid-123"
        }
        catch (Exception ex)
        {
            // LINE 10: Log any errors
            _logger.LogError(ex,
                "Failed to send real-time notifications for transfer {TransactionId}",
                notification.TransactionId);
            // Note: We DON'T re-throw because other handlers should still execute
        }
    }
}
```

---

## STEP 7: How SignalR Groups Work

### Background: When Clients Connected

```csharp
// File: CoreBankingTest.API/Hubs/EnhancedTransactionHub.cs

public override async Task OnConnectedAsync()
{
    // LINE 1: Client connects to hub with ?accountNumber=123456789
    var httpContext = Context.GetHttpContext();
    var accountNumber = httpContext?.Request.Query["accountNumber"].ToString();
    //                   "123456789"

    // LINE 2: Add this client to group for their account
    await Groups.AddToGroupAsync(Context.ConnectionId, $"account-{accountNumber}");
    //                            ConnectionId: "abc-123-def"
    //                            GroupName: "account-123456789"
    //       ↑ This client is now in the "account-123456789" group

    // LINE 3: Store connection info
    _connectionState.ConnectionEstablished(Context.ConnectionId, accountNumber, Context.UserIdentifier);

    await base.OnConnectedAsync();
}
```

**Current State:**

```
SignalR Groups:
═════════════════════════════════════════════════════════════

Group: "account-123456789"
├─ ConnectionId: "abc-123-def"  ← User A's browser
├─ ConnectionId: "xyz-789-ghi"  ← User C's browser
└─ (Any other clients viewing account 123456789)

Group: "account-987654321"
├─ ConnectionId: "def-456-jkl"  ← User B's browser
└─ (Any other clients viewing account 987654321)
```

---

## STEP 8: SignalR Sends to Groups

### When RealTimeNotificationEventHandler calls:

```csharp
await _hubContext.Clients
    .Group($"account-123456789")
    .ReceiveTransactionNotification(sourceNotification);
```

**What happens internally:**

```
SignalR Framework:
═════════════════════════════════════════════════════════════

Step 1: Get all connections in group "account-123456789"
        Connections: ["abc-123-def", "xyz-789-ghi"]

Step 2: For EACH connection:
        ┌─────────────────────────────────────────┐
        │ Connection: "abc-123-def" (User A)      │
        ├─────────────────────────────────────────┤
        │ Line 1: Serialize notification to JSON  │
        │ {                                       │
        │   "transactionId": "guid-123",          │
        │   "accountNumber": "123456789",         │
        │   "amount": -100,                       │
        │   "type": "Debit",                      │
        │   "description": "Transfer to 987654321"│
        │ }                                       │
        │                                         │
        │ Line 2: Send via WebSocket              │
        │ Message: "ReceiveTransactionNotification"
        │ Data: [JSON above]                      │
        │                                         │
        │ Line 3: Browser receives message        │
        │ JavaScript function triggered           │
        └─────────────────────────────────────────┘

        ┌─────────────────────────────────────────┐
        │ Connection: "xyz-789-ghi" (User C)      │
        ├─────────────────────────────────────────┤
        │ Same as above                           │
        └─────────────────────────────────────────┘
```

---

## STEP 9: JavaScript Handler Receives on Client

### File: `advanced-banking-client.html`

```javascript
// LINE 1: When connection is created, register message handler
connection.on("ReceiveTransactionNotification", (notification) => {
    //      ↑ Method name matches server's method call:
    //        .ReceiveTransactionNotification(notification)

    // ========== HANDLER CODE ==========

    // LINE 2: Log the notification
    console.log('New transaction:', notification);
    // Output: 
    // Object {
    //   transactionId: "guid-123",
    //   accountNumber: "123456789",
    //   amount: -100,
    //   type: "Debit",
    //   description: "Transfer to 987654321"
    // }

    // LINE 3: Create notification string
    var message = `Transaction: ${notification.type} - $${notification.amount} - ${notification.description}`;
    //             "Transaction: Debit - $-100 - Transfer to 987654321"

    // LINE 4: Add to UI
    addNotification(message, 'info');
    //             ↑ Creates new <div> element
    //             ↑ Adds to notifications container
    //             ↑ User sees it INSTANTLY!
});
```

---

## STEP 10: Create UI Element

```javascript
// FILE: advanced-banking-client.html
// FUNCTION: addNotification()

function addNotification(message, type = 'info') {
    // ========== LINE BY LINE EXECUTION ==========

    // LINE 1: Create new div element
    const div = document.createElement('div');
    //     ↑ <div></div>

    // LINE 2: Set CSS class based on type
    div.className = `notification ${type}`;
    //  Result: <div class="notification info"></div>

    // LINE 3: Set text content with timestamp
    div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    //                 "[16:22:08] Transaction: Debit - $-100 - Transfer to 987654321"
    // Result: <div class="notification info">[16:22:08] Transaction: Debit - $-100 - Transfer to 987654321</div>

    // LINE 4: Add to page at TOP (prepend, not append)
    notifications.prepend(div);
    //          ↑ New notifications appear at top
    // DOM:
    // <div id="notifications">
    //   <div class="notification info">[16:22:08] Transaction: Debit - $-100...</div>
    //   <div class="notification info">[16:22:07] Previous notification</div>
    //   ...
    // </div>

    // LINE 5: Keep only last 20 notifications (auto-cleanup)
    if (notifications.children.length > 20) {
        notifications.removeChild(notifications.lastChild);
        //                        ↑ Remove oldest notification
    }
}
```

---

## STEP 11: CSS Styling Applied

```css
/* From advanced-banking-client.html <style> tag */

.notification {
    padding: 10px;
    margin: 5px;
    border-radius: 5px;
}

.info {
    background: #d4edda;      /* Light green */
    border: 1px solid #c3e6cb;
    color: #155724;
}

.warning {
    background: #fff3cd;      /* Light yellow */
    border: 1px solid #ffeaa7;
}

.error {
    background: #f8d7da;      /* Light red */
    border: 1px solid #f5c6cb;
}
```

**Result on screen:**
```
┌──────────────────────────────────────────────────────────┐
│ Connection Status: Connected (green)                     │
├──────────────────────────────────────────────────────────┤
│ Notifications:                                           │
├──────────────────────────────────────────────────────────┤
│                                                          │
│ [16:22:08] Transaction: Debit - $-100 - Transfer to ... │
│ ┌────────────────────────────────────────────────────┐  │
│ │ Light green box with dark text                    │  │
│ │ Rounded corners                                    │  │
│ │ 10px padding                                       │  │
│ └────────────────────────────────────────────────────┘  │
│                                                          │
│ [16:22:05] Balance Updated: $400                       │
│ ┌────────────────────────────────────────────────────┐  │
│ │ Light green box                                    │  │
│ └────────────────────────────────────────────────────┘  │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

---

## COMPLETE SIGNALR FLOW TIMELINE

```
TIME    EVENT

T+0ms   User A initiates transfer in REST API
        POST /api/accounts/transfer
        { source: "123456789", destination: "987654321", amount: 100 }

T+1ms   REST endpoint calls _mediator.Send(TransferMoneyCommand)

T+2ms   MediatR pipeline:
        - ValidationBehavior: ✓ PASS
        - LoggingBehavior: ✓ START
        - DomainEventsBehavior: ✓ PREPARE

T+3ms   TransferMoneyCommandHandler executes:
        - Get source account (balance: 500)
        - Get dest account (balance: 1000)
        - Call account.Transfer()

T+4ms   Account.Transfer() executes:
        - source.Balance: 500 → 400
        - destination.Balance: 1000 → 1100
        - Create MoneyTransferredEvent
        - Add to account.DomainEvents (in memory)

T+5ms   UnitOfWork.CommitAsync():
        - Save both accounts to database
        - Create OutBoxMessage record
        - INSERT/UPDATE execute atomically

T+6ms   DomainEventsBehavior publishes event:
        await _mediator.Publish(MoneyTransferredEvent)

T+7ms   RealTimeNotificationEventHandler.Handle() called:
        - Create sourceNotification (Debit -100)
        - Create destNotification (Credit +100)
        - Send to groups

T+8ms   SignalR groups:
        await _hubContext.Clients
            .Group("account-123456789")
            .ReceiveTransactionNotification(sourceNotification)

T+9ms   WebSocket sends to connection "abc-123-def" (User A's browser)
        Message: {method: "ReceiveTransactionNotification", data: {...}}

T+10ms  User A's browser receives WebSocket message
        JavaScript handler: connection.on("ReceiveTransactionNotification", ...)

T+11ms  addNotification() called
        Creates <div> with notification
        Prepends to DOM

T+12ms  Browser renders new element
        [16:22:08] Transaction: Debit - $-100 - Transfer to 987654321

        (Light green box appears on screen!)

        ═══════════════════════════════════════════════════════════

T+8ms   SAME TIME: SignalR sends to connection "def-456-jkl" (User B)
        Message: {method: "ReceiveTransactionNotification", data: {...}}

T+10ms  User B's browser receives message
        JavaScript handler triggers

T+11ms  User B's addNotification() called

T+12ms  User B's browser renders:
        [16:22:08] Transaction: Credit - $100 - Transfer from 123456789

        (Light green box appears on User B's screen too!)

═══════════════════════════════════════════════════════════════════════
TOTAL TIME: 12 milliseconds from user clicking "Transfer" to both users
            seeing the notification LIVE!
```

---

## What Makes This Special

### Before (REST Only)
```
User A transfers money
        ↓
User B has NO IDEA
        ↓
User B must:
  • Manually refresh page
  • Wait for page load
  • See new balance

Worst case: 10-30 seconds delay!
```

### After (REST + SignalR)
```
User A transfers money
        ↓ (REST endpoint processes)
        ↓ (Domain event published)
        ↓ (SignalR handler sends)
User B sees notification INSTANTLY
        ↓
~12 milliseconds!
NO refresh needed!
LIVE dashboard experience!
```

---

## Connection State Tracking

### File: `ConnectionStateService.cs`

```csharp
public class ConnectionStateService
{
    // LINE 1: Thread-safe dictionary to track all connections
    private readonly ConcurrentDictionary<string, ConnectionTracking> _connections = new();
    //                ↑ Key: ConnectionId (e.g., "abc-123-def")
    //                ↑ Value: ConnectionTracking info

    // LINE 2: Timer to check connection health
    private readonly Timer _healthTimer;

    public ConnectionStateService(ILogger<ConnectionStateService> logger)
    {
        _logger = logger;
        
        // LINE 3: Start health check timer
        _healthTimer = new Timer(CheckConnectionHealth, null,
            TimeSpan.FromMinutes(1),  // First run after 1 minute
            TimeSpan.FromMinutes(1)   // Then every 1 minute
        );
    }

    // LINE 4: Called when client connects
    public void ConnectionEstablished(string connectionId, string accountNumber, string? userId)
    {
        var state = new ConnectionTracking
        {
            ConnectionId = connectionId,         // "abc-123-def"
            AccountNumber = accountNumber,       // "123456789"
            UserId = userId,                     // "alice@example.com"
            EstablishedAt = DateTime.UtcNow,    // Connection time
            LastActivity = DateTime.UtcNow,      // Last active time
            Status = ConnectionStatus.Connected  // Active
        };

        // LINE 5: Store in dictionary
        _connections[connectionId] = state;

        // LINE 6: Log connection
        _logger.LogInformation(
            "Connection established: {ConnectionId} for account {AccountNumber}",
            connectionId,
            accountNumber
        );
    }

    // LINE 7: Called when client sends a message
    public void ConnectionActivity(string connectionId)
    {
        if (_connections.TryGetValue(connectionId, out var state))
        {
            // LINE 8: Update last activity time
            state.LastActivity = DateTime.UtcNow;
            
            // LINE 9: Increment message counter
            state.MessagesSent++;
        }
    }

    // LINE 10: Called periodically by timer
    private void CheckConnectionHealth(object? state)
    {
        // LINE 11: Find idle connections (no activity for 2 minutes)
        var cutoff = DateTime.UtcNow.AddMinutes(-2);

        var staleConnections = _connections.Values
            .Where(c => c.LastActivity < cutoff && c.Status == ConnectionStatus.Connected)
            .ToList();

        // LINE 12: Mark as inactive
        foreach (var connection in staleConnections)
        {
            _logger.LogWarning(
                "Marking stale connection {ConnectionId} as inactive",
                connection.ConnectionId
            );
            connection.Status = ConnectionStatus.Inactive;
        }
    }

    // LINE 13: Called when client disconnects
    public void ConnectionTerminated(string connectionId, ConnectionStatus status = ConnectionStatus.Disconnected)
    {
        if (_connections.TryRemove(connectionId, out var state))
        {
            // LINE 14: Record termination
            state.Status = status;
            state.TerminatedAt = DateTime.UtcNow;

            // LINE 15: Log disconnection
            _logger.LogInformation(
                "Connection terminated: {ConnectionId} with status {Status}",
                connectionId,
                status
            );
        }
    }
}
```

---

## Summary: gRPC vs SignalR

### gRPC (Service-to-Service)
```
✓ High performance (binary, HTTP/2)
✓ 4 streaming modes
✓ Strongly typed messages
✗ Not web-friendly (need special client)
✗ Not for browser clients

Used for: Bank servers talking to other services
Example: GetAccount, StreamTransactions, BatchTransfer
```

### SignalR (Client-to-Service)
```
✓ Real-time push from server
✓ Groups for broadcasting
✓ Works in browsers (JavaScript)
✓ Auto-reconnect
✗ Slightly higher overhead
✗ Not optimal for high-throughput service calls

Used for: Server pushing updates to web clients
Example: Real-time transaction notifications, live dashboards
```

### Together in Your System
```
┌─────────────────────────────────────────────┐
│ Bank Backend (C# .NET)                      │
│                                             │
│ • REST API (HTTP/1.1 on port 5037)          │
│ • gRPC (HTTP/2 on port 7288)               │
│ • SignalR WebSocket (port 5037)             │
│                                             │
│ Domain Layer ← DDD + CQRS + MediatR        │
│ ↓                                           │
│ Database ← Atomic transactions + Outbox     │
└─────────────────────────────────────────────┘
        ↑              ↑              ↑
        │              │              │
      REST           gRPC         SignalR
        │              │              │
┌───────┴───┐    ┌────┴─────┐    ┌──┴────────┐
│  Browser  │    │ Services  │    │ Browser   │
│  (REST)   │    │  (.NET)   │    │ (Real-time│
│           │    │  (Java)   │    │ dashboard)│
│ Swagger   │    │  (Python) │    │           │
│ Manual    │    │ High-perf │    │ Live      │
│ requests  │    │           │    │ updates   │
└───────────┘    └───────────┘    └───────────┘
```

